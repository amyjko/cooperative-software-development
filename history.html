<!DOCTYPE html>
<html>
	<head>

		<meta name="viewport" content="width=device-width, initial-scale=1">

		<!-- Latest compiled and minified CSS -->
		<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
		
		<!-- Optional theme -->
		<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap-theme.min.css" integrity="sha384-rHyoN1iRsVXV4nD0JutlnGaslCJuC7uwjduW9SVrLvRYooPp2bWYgmgJQIXwl/Sp" crossorigin="anonymous">
		
		<!-- Latest compiled and minified JavaScript -->
		<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>
		
		<link rel="stylesheet" href="style.css" />

		<title>The history of software engineering</title>
		
	</head>
	<body>
		<p><a href="index.html">Back to table of contents</a></p>

		<img src="images/punchcard.jpg" class="img-responsive" />		
		<small>Credit: unknown</small>
		
		<h1>A brief history of software engineering</h1>
		<div class="lead">Andrew J. Ko</div>

		<p>Computers haven't been around for long. If you read one of the many histories of computing and information, such as James Gleick's <a href="https://www.amazon.com/Information-History-Theory-Flood/dp/1400096235">The Information</a>, or <a href="https://www.amazon.com/Tool-Partner-Evolution-Human-Computer-Interaction/dp/1627059636">Jonathan Grudin's History of HCI</a>, you'll learn that before <em>digital</em> computers, computers were people, calculating things manually, as portrayed in the film <a href="https://en.wikipedia.org/wiki/Hidden_Figures">Hidden Figures</a> (watch it if you haven't!). And that <em>after</em> digital computers, programming wasn't something that many people did. It was reserved for whoever had access to the mainframe and they wrote their programs on punchcards like the one above. Computing was in no way a ubiquitous, democratized activity&mdash;it was reserved for the few that could afford and maintain a room-sized machine.</p>
		
		 <p>Because programming required such painstaking planning in machine code and computers were slow, most programs were not that complex. Their value was in calculating things faster than a person could do by hand, which meant thousands of calculations in a minute rather than one calculation in a minute. Computer programmers were not solving problems that had no solutions; they were translating existing solutions (for example, a quadratic formula) into the notation a computer understood. Their power wasn't in creating new realities or facilitating new tasks, it was accelerating old tasks.</p>
	
		<p>The birth of software engineering, therefore, did not come until programmers started solving problems that <em>didn't</em> have existing solutions, or were new ideas entirely. Most of these were done in academic contexts to develop things like basic operating systems and methods of input and output. These were complex projects, but as research, they didn't need to scale; they just needed to work. It wasn't until the late 1960's, when the first truly large software projects were attempted commercially, and software had to actually work.</p>
		
		<p>The IBM 360 operating system was one of the first big projects of this kind. Suddenly, there were multiple people working on multiple components, all which interacted. Different parts of the program needed to coordinate, which meant different <em>people</em> needed to coordinate, and the term <em>software engineering</em> was born. Programmers and academics from around the world, especially those that were working on big projects, began to start conferences so they could meet and discuss their challenges. In the <a href="http://homepages.cs.ncl.ac.uk/brian.randell/NATO/nato1968.PDF">first software engineering conference</a> in 1968, attendees speculated about why projects were shipping late, why they were over budget, and what to do about it.</p>
		
		<p>In these early days of software engineering, programmers, managers, and researchers discovered many problems that had no clear solutions:</p>
		
		<ul>
			<li>When you're solving a problem that doesn't yet have a solution, what is a good process for building a solution?</li>
			<li>When software does so many different things, how can you know software "works"?</li>
			<li>How can you make progress when <em>no one</em> on the team understands every part of the program?</li>
			<li>When people leave a project, how do you ensure their replacement has all of the knowledge they had?</li>
			<li>When no one understands every part of the program, how do you diagnose defects?</li>
			<li>When people are working in parallel, how do you prevent them from clobbering each other's work?</li>
			<li>If software engineering is about more than coding, what skills does a good coder need to have?</li>
			<li>What kinds of tools and languages can accelerate a programmers work and help them prevent mistakes?</li>
		</ul>
		
		<p>These questions are at the foundation of the field of software engineering and are the core content of this course. Some of them have pretty good answers. For example, the research community rapidly converged toward the concept of a version control systems, software testing, and a wide array of high-level programming languages such as Fortran (<a href="#metcalf">Metcalf 2002</a>), LISP (<a href="mccarthy">McCarthy 1978</a>), C++ (<a href="#stroustrup">Stroustrup 1996</a>), and Smalltalk (<a href="#kay">Kay 1996</a>), all of which were precursors to today's modern languages such as Java, Python, and JavaScript.</p>
		
		<p>Other questions, particularly those concerning the <em>human</em> aspects of software engineering, were hopelessly difficult to understand and improve. One of the seminal books on these issues was Fred P. Brooks, Jr.'s <em>The Mythical Man Month</em>. In it, he presented hundreds of claims about software engineering. For example, he hypothesized that adding more programmers to a project would actually make productivity <em>worse</em> at some level, not better, because of the added burden of knowledge sharing. He also claimed that the <em>first</em> implementation of a solution is usually terrible and should be treated like a prototype: used to learn and then discarded. These and other claims have been the foundation of decades of years of research, all in search of some deeper answer to the questions above.</p>
		
		<p>If we step beyond software engineering and think more broadly about the role that software is playing in society today, there are also other, newer questions that we've only begun to answer. If every part of society now runs on code, what responsibility do software engineers have to ensure that code is right? What responsibility do software engineers have to avoid algorithmic bias? If our cars are to soon drive us around, who's responsible for the first death: the car, the driver, or the software engineers who built it? These ethical questions are in some ways the <em>future</em> of software engineering, likely to shape it's regulatory context, its processes, and it's responsibilities.</p>
		
		<p>There are also <em>economic</em> roles that software plays in society that it didn't before. Around the world, it's a major source of job growth, but also a major source of automation, eliminating jobs that people used to do. These larger forces that software is playing on the world demand that software engineers have a stronger understanding of the roles that software plays in society, as the decisions that engineers make can have profoundly impactful unintended consequences.<p>

		<p>We're nowhere close to having deep answers about these questions, neither the old ones or the new ones. We know <em>a lot</em> about programming languages and <em>a lot</em> about testing. These are areas amenable to automation and so computer science has rapidly improved and accelerated these parts of software engineering. The rest of it, as we shall see in this, has not made much progress. In this class, we'll discuss what we know and the much larger space of what we don't.</p>

		<center class="lead"><a href="organizations.html">Next chapter: Organizations</a></center>

		<h2>Further reading</h2>

		<p>Brooks Jr, F. P. (1995). <a href="https://books.google.com/books?id=Yq35BY5Fk3gC" target="_blank">The Mythical Man-Month (anniversary ed.)</a>. Chicago</p>
		<p>Gleick, James (2011). <a href="https://books.google.com/books?id=617JSFW0D2kC" target="_blank">The Information: A History, A Theory, A Flood</a>. Pantheon Books.</p>
		<p>Grudin, Jonathan (2017). <a href="https://books.google.com/books?id=Wc3hDQAAQBAJ" target="_blank">From Tool to Partner: The Evolution of Human-Computer Interaction</a>.</p>
		<p id="kay">Kay, A. C. (1996, January). <a href="http://dl.acm.org/citation.cfm?id=1057828" target="_blank">The early history of Smalltalk</a>. In History of programming languages---II (pp. 511-598). ACM.</p>
		<p>Ko, A. J. (2016). <a href="http://softwareengineeringdaily.com/2016/02/24/academia-to-industry-in-computer-science-with-andy-ko/">Interview with Andrew Ko on Software Engineering Daily about Software Engineering Research and Practice</a>.</p>
		<p id="mccarthy">McCarthy, J. (1978, June). <a href="http://dl.acm.org/citation.cfm?id=1198360" target="_blank">History of LISP</a>. In History of programming languages I (pp. 173-185). ACM.</p>
		<p id="metcalf">Metcalf, M. (2002, December). <a href="http://dl.acm.org/citation.cfm?id=602379" target="_blank">History of Fortran</a>. In ACM SIGPLAN Fortran Forum (Vol. 21, No. 3, pp. 19-20). ACM.</p>
		<p id="stroustrup">Stroustrup, B. (1996, January). <a href="http://dl.acm.org/citation.cfm?id=1057836" target="_blank">A history of C++: 1979--1991</a>. In History of programming languages---II (pp. 699-769). ACM.</p>

	</body>

</html>



